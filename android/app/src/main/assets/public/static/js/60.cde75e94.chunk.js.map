{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5/ion-refresher_2-ios.entry.js","../node_modules/@ionic/core/dist/esm-es5/index-cae2ca23.js"],"names":["__webpack_require__","r","__webpack_exports__","d","Refresher","RefresherContent","tslib__WEBPACK_IMPORTED_MODULE_0__","_core_13ed1ad7_js__WEBPACK_IMPORTED_MODULE_1__","_config_bb99b659_js__WEBPACK_IMPORTED_MODULE_2__","_index_cae2ca23_js__WEBPACK_IMPORTED_MODULE_3__","class_1","hostRef","Object","this","appliedStyles","didStart","progress","state","pullMin","pullMax","closeDuration","snapbackDuration","pullFactor","disabled","ionRefresh","ionPull","ionStart","prototype","disabledChanged","gesture","setDisabled","componentDidLoad","contentEl","_a","_b","_this","_c","label","el","getAttribute","console","error","closest","getScrollElement","scrollEl","sent","Promise","resolve","then","bind","createGesture","gestureName","gesturePriority","direction","threshold","passive","canStart","onStart","onMove","ev","onEnd","componentDidUnload","undefined","destroy","complete","close","cancel","getProgress","scrollTop","detail","event","touches","length","Number","isNaN","deltaY","setCss","cancelable","preventDefault","emit","beginRefresh","delay","setTimeout","y","duration","overflowVisible","style","transform","transitionDuration","transitionDelay","overflow","render","mode","slot","class","defineProperty","get","enumerable","configurable","class_2","componentWillLoad","pullingIcon","refreshingSpinner","icon","lazy","pullingText","innerHTML","name","refreshingText","sanitizeDOMString","untrustedString","documentFragment_1","document","createDocumentFragment","workingDiv","createElement","appendChild","blockedTags","forEach","blockedTag","getElementsToRemove","querySelectorAll","elementIndex","element","parentNode","removeChild","childElements","getElementChildren","childIndex","sanitizeElement","documentFragmentChildren","fragmentDiv","getInnerDiv","querySelector","err","nodeType","i","attributes","attribute","attributeName","allowedAttributes","includes","toLowerCase","attributeValue","value","removeAttribute","children","childNodes"],"mappings":"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","file":"static/js/60.cde75e94.chunk.js","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { r as registerInstance, c as createEvent, w as writeTask, d as getIonMode, h, e as getElement, H as Host } from './core-13ed1ad7.js';\nimport { b as config } from './config-bb99b659.js';\nimport { s as sanitizeDOMString } from './index-cae2ca23.js';\n\nvar Refresher =\n/** @class */\nfunction () {\n  function class_1(hostRef) {\n    registerInstance(this, hostRef);\n    this.appliedStyles = false;\n    this.didStart = false;\n    this.progress = 0;\n    /**\n     * The current state which the refresher is in. The refresher's states include:\n     *\n     * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.\n     * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.\n     * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.\n     * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.\n     * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.\n     * - `completing` - The `refreshing` state has finished and the refresher is in the way of closing itself. Once closed, the refresher will go back to the `inactive` state.\n     */\n\n    this.state = 1\n    /* Inactive */\n    ;\n    /**\n     * The minimum distance the user must pull down until the\n     * refresher will go into the `refreshing` state.\n     */\n\n    this.pullMin = 60;\n    /**\n     * The maximum distance of the pull until the refresher\n     * will automatically go into the `refreshing` state.\n     * Defaults to the result of `pullMin + 60`.\n     */\n\n    this.pullMax = this.pullMin + 60;\n    /**\n     * Time it takes to close the refresher.\n     */\n\n    this.closeDuration = '280ms';\n    /**\n     * Time it takes the refresher to to snap back to the `refreshing` state.\n     */\n\n    this.snapbackDuration = '280ms';\n    /**\n     * How much to multiply the pull speed by. To slow the pull animation down,\n     * pass a number less than `1`. To speed up the pull, pass a number greater\n     * than `1`. The default value is `1` which is equal to the speed of the cursor.\n     * If a negative value is passed in, the factor will be `1` instead.\n     *\n     * For example: If the value passed is `1.2` and the content is dragged by\n     * `10` pixels, instead of `10` pixels the content will be pulled by `12` pixels\n     * (an increase of 20 percent). If the value passed is `0.8`, the dragged amount\n     * will be `8` pixels, less than the amount the cursor has moved.\n     */\n\n    this.pullFactor = 1;\n    /**\n     * If `true`, the refresher will be hidden.\n     */\n\n    this.disabled = false;\n    this.ionRefresh = createEvent(this, \"ionRefresh\", 7);\n    this.ionPull = createEvent(this, \"ionPull\", 7);\n    this.ionStart = createEvent(this, \"ionStart\", 7);\n  }\n\n  class_1.prototype.disabledChanged = function () {\n    if (this.gesture) {\n      this.gesture.setDisabled(this.disabled);\n    }\n  };\n\n  class_1.prototype.componentDidLoad = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var contentEl, _a, _b;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (this.el.getAttribute('slot') !== 'fixed') {\n              console.error('Make sure you use: <ion-refresher slot=\"fixed\">');\n              return [2\n              /*return*/\n              ];\n            }\n\n            contentEl = this.el.closest('ion-content');\n            if (!contentEl) return [3\n            /*break*/\n            , 2];\n            _a = this;\n            return [4\n            /*yield*/\n            , contentEl.getScrollElement()];\n\n          case 1:\n            _a.scrollEl = _c.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            console.error('ion-refresher did not attach, make sure the parent is an ion-content.');\n            _c.label = 3;\n\n          case 3:\n            _b = this;\n            return [4\n            /*yield*/\n            , import('./index-2c4a5477.js')];\n\n          case 4:\n            _b.gesture = _c.sent().createGesture({\n              el: this.el.closest('ion-content'),\n              gestureName: 'refresher',\n              gesturePriority: 10,\n              direction: 'y',\n              threshold: 20,\n              passive: false,\n              canStart: function canStart() {\n                return _this.canStart();\n              },\n              onStart: function onStart() {\n                return _this.onStart();\n              },\n              onMove: function onMove(ev) {\n                return _this.onMove(ev);\n              },\n              onEnd: function onEnd() {\n                return _this.onEnd();\n              }\n            });\n            this.disabledChanged();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.componentDidUnload = function () {\n    this.scrollEl = undefined;\n\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  };\n  /**\n   * Call `complete()` when your async operation has completed.\n   * For example, the `refreshing` state is while the app is performing\n   * an asynchronous operation, such as receiving more data from an\n   * AJAX request. Once the data has been received, you then call this\n   * method to signify that the refreshing has completed and to close\n   * the refresher. This method also changes the refresher's state from\n   * `refreshing` to `completing`.\n   */\n\n\n  class_1.prototype.complete = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        this.close(32\n        /* Completing */\n        , '120ms');\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Changes the refresher's state from `refreshing` to `cancelling`.\n   */\n\n\n  class_1.prototype.cancel = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        this.close(16\n        /* Cancelling */\n        , '');\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * A number representing how far down the user has pulled.\n   * The number `0` represents the user hasn't pulled down at all. The\n   * number `1`, and anything greater than `1`, represents that the user\n   * has pulled far enough down that when they let go then the refresh will\n   * happen. If they let go and the number is less than `1`, then the\n   * refresh will not happen, and the content will return to it's original\n   * position.\n   */\n\n\n  class_1.prototype.getProgress = function () {\n    return Promise.resolve(this.progress);\n  };\n\n  class_1.prototype.canStart = function () {\n    if (!this.scrollEl) {\n      return false;\n    }\n\n    if (this.state !== 1\n    /* Inactive */\n    ) {\n        return false;\n      } // if the scrollTop is greater than zero then it's\n    // not possible to pull the content down yet\n\n\n    if (this.scrollEl.scrollTop > 0) {\n      return false;\n    }\n\n    return true;\n  };\n\n  class_1.prototype.onStart = function () {\n    this.progress = 0;\n    this.state = 1\n    /* Inactive */\n    ;\n  };\n\n  class_1.prototype.onMove = function (detail) {\n    if (!this.scrollEl) {\n      return;\n    } // this method can get called like a bazillion times per second,\n    // so it's built to be as efficient as possible, and does its\n    // best to do any DOM read/writes only when absolutely necessary\n    // if multi-touch then get out immediately\n\n\n    var ev = detail.event;\n\n    if (ev.touches && ev.touches.length > 1) {\n      return;\n    } // do nothing if it's actively refreshing\n    // or it's in the way of closing\n    // or this was never a startY\n\n\n    if ((this.state & 56\n    /* _BUSY_ */\n    ) !== 0) {\n      return;\n    }\n\n    var pullFactor = Number.isNaN(this.pullFactor) || this.pullFactor < 0 ? 1 : this.pullFactor;\n    var deltaY = detail.deltaY * pullFactor; // don't bother if they're scrolling up\n    // and have not already started dragging\n\n    if (deltaY <= 0) {\n      // the current Y is higher than the starting Y\n      // so they scrolled up enough to be ignored\n      this.progress = 0;\n      this.state = 1\n      /* Inactive */\n      ;\n\n      if (this.appliedStyles) {\n        // reset the styles only if they were applied\n        this.setCss(0, '', false, '');\n        return;\n      }\n\n      return;\n    }\n\n    if (this.state === 1\n    /* Inactive */\n    ) {\n        // this refresh is not already actively pulling down\n        // get the content's scrollTop\n        var scrollHostScrollTop = this.scrollEl.scrollTop; // if the scrollTop is greater than zero then it's\n        // not possible to pull the content down yet\n\n        if (scrollHostScrollTop > 0) {\n          this.progress = 0;\n          return;\n        } // content scrolled all the way to the top, and dragging down\n\n\n        this.state = 2\n        /* Pulling */\n        ;\n      } // prevent native scroll events\n\n\n    if (ev.cancelable) {\n      ev.preventDefault();\n    } // the refresher is actively pulling at this point\n    // move the scroll element within the content element\n\n\n    this.setCss(deltaY, '0ms', true, '');\n\n    if (deltaY === 0) {\n      // don't continue if there's no delta yet\n      this.progress = 0;\n      return;\n    }\n\n    var pullMin = this.pullMin; // set pull progress\n\n    this.progress = deltaY / pullMin; // emit \"start\" if it hasn't started yet\n\n    if (!this.didStart) {\n      this.didStart = true;\n      this.ionStart.emit();\n    } // emit \"pulling\" on every move\n\n\n    this.ionPull.emit(); // do nothing if the delta is less than the pull threshold\n\n    if (deltaY < pullMin) {\n      // ensure it stays in the pulling state, cuz its not ready yet\n      this.state = 2\n      /* Pulling */\n      ;\n      return;\n    }\n\n    if (deltaY > this.pullMax) {\n      // they pulled farther than the max, so kick off the refresh\n      this.beginRefresh();\n      return;\n    } // pulled farther than the pull min!!\n    // it is now in the `ready` state!!\n    // if they let go then it'll refresh, kerpow!!\n\n\n    this.state = 4\n    /* Ready */\n    ;\n    return;\n  };\n\n  class_1.prototype.onEnd = function () {\n    // only run in a zone when absolutely necessary\n    if (this.state === 4\n    /* Ready */\n    ) {\n        // they pulled down far enough, so it's ready to refresh\n        this.beginRefresh();\n      } else if (this.state === 2\n    /* Pulling */\n    ) {\n        // they were pulling down, but didn't pull down far enough\n        // set the content back to it's original location\n        // and close the refresher\n        // set that the refresh is actively cancelling\n        this.cancel();\n      }\n  };\n\n  class_1.prototype.beginRefresh = function () {\n    // assumes we're already back in a zone\n    // they pulled down far enough, so it's ready to refresh\n    this.state = 8\n    /* Refreshing */\n    ; // place the content in a hangout position while it thinks\n\n    this.setCss(this.pullMin, this.snapbackDuration, true, ''); // emit \"refresh\" because it was pulled down far enough\n    // and they let go to begin refreshing\n\n    this.ionRefresh.emit({\n      complete: this.complete.bind(this)\n    });\n  };\n\n  class_1.prototype.close = function (state, delay) {\n    var _this = this; // create fallback timer incase something goes wrong with transitionEnd event\n\n\n    setTimeout(function () {\n      _this.state = 1\n      /* Inactive */\n      ;\n      _this.progress = 0;\n      _this.didStart = false;\n\n      _this.setCss(0, '0ms', false, '');\n    }, 600); // reset set the styles on the scroll element\n    // set that the refresh is actively cancelling/completing\n\n    this.state = state;\n    this.setCss(0, this.closeDuration, true, delay); // TODO: stop gesture\n  };\n\n  class_1.prototype.setCss = function (y, duration, overflowVisible, delay) {\n    var _this = this;\n\n    this.appliedStyles = y > 0;\n    writeTask(function () {\n      if (_this.scrollEl) {\n        var style = _this.scrollEl.style;\n        style.transform = y > 0 ? \"translateY(\" + y + \"px) translateZ(0px)\" : 'translateZ(0px)';\n        style.transitionDuration = duration;\n        style.transitionDelay = delay;\n        style.overflow = overflowVisible ? 'hidden' : '';\n      }\n    });\n  };\n\n  class_1.prototype.render = function () {\n    var _a;\n\n    var mode = getIonMode(this);\n    return h(Host, {\n      slot: \"fixed\",\n      class: (_a = {}, _a[mode] = true, // Used internally for styling\n      _a[\"refresher-\" + mode] = true, _a['refresher-active'] = this.state !== 1\n      /* Inactive */\n      , _a['refresher-pulling'] = this.state === 2\n      /* Pulling */\n      , _a['refresher-ready'] = this.state === 4\n      /* Ready */\n      , _a['refresher-refreshing'] = this.state === 8\n      /* Refreshing */\n      , _a['refresher-cancelling'] = this.state === 16\n      /* Cancelling */\n      , _a['refresher-completing'] = this.state === 32\n      /* Completing */\n      , _a)\n    });\n  };\n\n  Object.defineProperty(class_1.prototype, \"el\", {\n    get: function get() {\n      return getElement(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(class_1, \"watchers\", {\n    get: function get() {\n      return {\n        \"disabled\": [\"disabledChanged\"]\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(class_1, \"style\", {\n    get: function get() {\n      return \"ion-refresher{left:0;top:0;display:none;position:absolute;width:100%;height:60px;z-index:-1}:host-context([dir=rtl]) ion-refresher,[dir=rtl] ion-refresher{left:unset;right:unset;right:0}ion-refresher.refresher-active{display:block}ion-refresher-content{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;height:100%}.refresher-pulling,.refresher-refreshing{display:none;width:100%}.refresher-pulling-icon,.refresher-refreshing-icon{-webkit-transform-origin:center;transform-origin:center;-webkit-transition:.2s;transition:.2s;font-size:30px;text-align:center}:host-context([dir=rtl]) .refresher-pulling-icon,:host-context([dir=rtl]) .refresher-refreshing-icon,[dir=rtl] .refresher-pulling-icon,[dir=rtl] .refresher-refreshing-icon{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}.refresher-pulling-text,.refresher-refreshing-text{font-size:16px;text-align:center}.refresher-pulling ion-refresher-content .refresher-pulling,.refresher-ready ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling-icon{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.refresher-cancelling ion-refresher-content .refresher-pulling,.refresher-refreshing ion-refresher-content .refresher-refreshing{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling-icon{-webkit-transform:scale(0);transform:scale(0)}.refresher-completing ion-refresher-content .refresher-refreshing{display:block}.refresher-completing ion-refresher-content .refresher-refreshing-icon{-webkit-transform:scale(0);transform:scale(0)}.refresher-ios .refresher-pulling-icon,.refresher-ios .refresher-pulling-text,.refresher-ios .refresher-refreshing-icon,.refresher-ios .refresher-refreshing-text{color:var(--ion-text-color,#000)}.refresher-ios .refresher-refreshing .spinner-crescent circle,.refresher-ios .refresher-refreshing .spinner-lines-ios line,.refresher-ios .refresher-refreshing .spinner-lines-small-ios line{stroke:var(--ion-text-color,#000)}.refresher-ios .refresher-refreshing .spinner-bubbles circle,.refresher-ios .refresher-refreshing .spinner-circles circle,.refresher-ios .refresher-refreshing .spinner-dots circle{fill:var(--ion-text-color,#000)}\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return class_1;\n}();\n\nvar RefresherContent =\n/** @class */\nfunction () {\n  function class_2(hostRef) {\n    registerInstance(this, hostRef);\n  }\n\n  class_2.prototype.componentWillLoad = function () {\n    if (this.pullingIcon === undefined) {\n      this.pullingIcon = config.get('refreshingIcon', 'arrow-down');\n    }\n\n    if (this.refreshingSpinner === undefined) {\n      var mode = getIonMode(this);\n      this.refreshingSpinner = config.get('refreshingSpinner', config.get('spinner', mode === 'ios' ? 'lines' : 'crescent'));\n    }\n  };\n\n  class_2.prototype.render = function () {\n    return h(Host, {\n      class: getIonMode(this)\n    }, h(\"div\", {\n      class: \"refresher-pulling\"\n    }, this.pullingIcon && h(\"div\", {\n      class: \"refresher-pulling-icon\"\n    }, h(\"ion-icon\", {\n      icon: this.pullingIcon,\n      lazy: false\n    })), this.pullingText && h(\"div\", {\n      class: \"refresher-pulling-text\",\n      innerHTML: sanitizeDOMString(this.pullingText)\n    })), h(\"div\", {\n      class: \"refresher-refreshing\"\n    }, this.refreshingSpinner && h(\"div\", {\n      class: \"refresher-refreshing-icon\"\n    }, h(\"ion-spinner\", {\n      name: this.refreshingSpinner\n    })), this.refreshingText && h(\"div\", {\n      class: \"refresher-refreshing-text\",\n      innerHTML: sanitizeDOMString(this.refreshingText)\n    })));\n  };\n\n  return class_2;\n}();\n\nexport { Refresher as ion_refresher, RefresherContent as ion_refresher_content };","/**\n * Does a simple sanitization of all elements\n * in an untrusted string\n */\nvar sanitizeDOMString = function sanitizeDOMString(untrustedString) {\n  try {\n    if (typeof untrustedString !== 'string' || untrustedString === '') {\n      return untrustedString;\n    }\n    /**\n     * Create a document fragment\n     * separate from the main DOM,\n     * create a div to do our work in\n     */\n\n\n    var documentFragment_1 = document.createDocumentFragment();\n    var workingDiv = document.createElement('div');\n    documentFragment_1.appendChild(workingDiv);\n    workingDiv.innerHTML = untrustedString;\n    /**\n     * Remove any elements\n     * that are blocked\n     */\n\n    blockedTags.forEach(function (blockedTag) {\n      var getElementsToRemove = documentFragment_1.querySelectorAll(blockedTag);\n\n      for (var elementIndex = getElementsToRemove.length - 1; elementIndex >= 0; elementIndex--) {\n        var element = getElementsToRemove[elementIndex];\n\n        if (element.parentNode) {\n          element.parentNode.removeChild(element);\n        } else {\n          documentFragment_1.removeChild(element);\n        }\n        /**\n         * We still need to sanitize\n         * the children of this element\n         * as they are left behind\n         */\n\n\n        var childElements = getElementChildren(element);\n        /* tslint:disable-next-line */\n\n        for (var childIndex = 0; childIndex < childElements.length; childIndex++) {\n          sanitizeElement(childElements[childIndex]);\n        }\n      }\n    });\n    /**\n     * Go through remaining elements and remove\n     * non-allowed attribs\n     */\n    // IE does not support .children on document fragments, only .childNodes\n\n    var documentFragmentChildren = getElementChildren(documentFragment_1);\n    /* tslint:disable-next-line */\n\n    for (var childIndex = 0; childIndex < documentFragmentChildren.length; childIndex++) {\n      sanitizeElement(documentFragmentChildren[childIndex]);\n    } // Append document fragment to div\n\n\n    var fragmentDiv = document.createElement('div');\n    fragmentDiv.appendChild(documentFragment_1); // First child is always the div we did our work in\n\n    var getInnerDiv = fragmentDiv.querySelector('div');\n    return getInnerDiv !== null ? getInnerDiv.innerHTML : fragmentDiv.innerHTML;\n  } catch (err) {\n    console.error(err);\n    return '';\n  }\n};\n/**\n * Clean up current element based on allowed attributes\n * and then recursively dig down into any child elements to\n * clean those up as well\n */\n\n\nvar sanitizeElement = function sanitizeElement(element) {\n  // IE uses childNodes, so ignore nodes that are not elements\n  if (element.nodeType && element.nodeType !== 1) {\n    return;\n  }\n\n  for (var i = element.attributes.length - 1; i >= 0; i--) {\n    var attribute = element.attributes[i];\n    var attributeName = attribute.name; // remove non-allowed attribs\n\n    if (!allowedAttributes.includes(attributeName.toLowerCase())) {\n      element.removeAttribute(attributeName);\n      continue;\n    } // clean up any allowed attribs\n    // that attempt to do any JS funny-business\n\n\n    var attributeValue = attribute.value;\n    /* tslint:disable-next-line */\n\n    if (attributeValue != null && attributeValue.toLowerCase().includes('javascript:')) {\n      element.removeAttribute(attributeName);\n    }\n  }\n  /**\n   * Sanitize any nested children\n   */\n\n\n  var childElements = getElementChildren(element);\n  /* tslint:disable-next-line */\n\n  for (var i = 0; i < childElements.length; i++) {\n    sanitizeElement(childElements[i]);\n  }\n};\n/**\n * IE doesn't always support .children\n * so we revert to .childNodes instead\n */\n\n\nvar getElementChildren = function getElementChildren(element) {\n  return element.children != null ? element.children : element.childNodes;\n};\n\nvar allowedAttributes = ['class', 'id', 'href', 'src', 'name', 'slot'];\nvar blockedTags = ['script', 'style', 'iframe', 'meta', 'link', 'object', 'embed'];\nexport { sanitizeDOMString as s };"],"sourceRoot":""}